<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tech Tree</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        background: #0d1117;
        font-family: "Segoe UI", system-ui, sans-serif;
        overflow: hidden;
      }

      #viewport {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        cursor: grab;
        position: relative;
      }

      #viewport.dragging {
        cursor: grabbing;
      }

      #canvas-wrap {
        position: absolute;
        top: 0;
        left: 0;
        transform-origin: 0 0;
      }

      svg#lines {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
      }

      #nodes {
        position: absolute;
        top: 0;
        left: 0;
      }

      .tech-node {
        position: absolute;
        width: 160px;
        background: #161b22;
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 8px 10px;
        transition:
          border-color 0.15s,
          box-shadow 0.15s;
        cursor: default;
        user-select: none;
      }

      .tech-node:hover {
        border-color: #58a6ff;
        box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        z-index: 10;
      }

      .tech-node .title {
        font-size: 11px;
        font-weight: 600;
        color: #e6edf3;
        margin-bottom: 5px;
        line-height: 1.3;
      }

      .tech-node .era {
        font-size: 9px;
        color: #8b949e;
        margin-bottom: 5px;
        text-transform: uppercase;
        letter-spacing: 0.4px;
      }

      .tech-node .items {
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .tech-node .items li {
        font-size: 9.5px;
        color: #7ee787;
        line-height: 1.3;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .tech-node .items li::before {
        content: "▸ ";
        color: #3fb950;
        font-size: 8px;
      }

      .tech-node .items li.hidden {
        display: none;
      }

      .tech-node .toggle-more {
        margin-top: 3px;
        font-size: 9px;
        color: #58a6ff;
        cursor: pointer;
        background: none;
        border: none;
        padding: 0;
        text-align: left;
        line-height: 1.4;
      }
      .tech-node .toggle-more:hover {
        color: #79c0ff;
        text-decoration: underline;
      }

      .era-separator {
        position: absolute;
        height: 1px;
        background: #30363d;
        left: 0;
        right: 0;
        pointer-events: none;
        opacity: 0.6;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .era-separator h1 {
        font-size: 14px;
        font-weight: 600;
        color: #e6edf3;
        margin: 0;
        padding: 0 12px;
        background: #0d1117;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      #timeline {
        position: absolute;
        left: -24px;
        top: 0;
        width: 60px;
        pointer-events: none;
        color: #8b949e;
        font-size: 10px;
      }

      .timeline-mark {
        position: absolute;
        left: 0;
        width: 100%;
        height: 1px;
        border-left: 3px solid #30363d;
        display: flex;
        align-items: center;
        padding-left: 8px;
        white-space: nowrap;
      }

      #hud {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 100;
      }

      #hud button {
        background: #21262d;
        border: 1px solid #30363d;
        color: #c9d1d9;
        padding: 6px 14px;
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        transition: background 0.1s;
      }

      #hud button:hover {
        background: #30363d;
      }

      #info {
        position: fixed;
        top: 16px;
        left: 16px;
        color: #8b949e;
        font-size: 11px;
        z-index: 100;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="viewport">
      <div id="canvas-wrap">
        <svg id="lines"></svg>
        <div id="timeline"></div>
        <div id="separators"></div>
        <div id="nodes"></div>
      </div>
    </div>

    <div id="hud">
      <button onclick="resetView()">Reset View</button>
      <button onclick="zoom(1.2)">+</button>
      <button onclick="zoom(0.8)">−</button>
    </div>

    <div id="info">Scroll to zoom · Drag to pan · 164 technologies</div>

    <script>
      const CELL_W = 50; // px per x grid unit
      const CELL_H = 80; // px per y grid unit
      const NODE_W = 160;
      const NODE_H_MIN = 60;
      const PAD_X = 30; // canvas padding
      const PAD_Y = 30;

      const STORAGE_KEY = "tech-tree-view";

      function saveView() {
        sessionStorage.setItem(STORAGE_KEY, JSON.stringify({ scale, tx, ty }));
      }

      function loadView() {
        try {
          return JSON.parse(sessionStorage.getItem(STORAGE_KEY));
        } catch {
          return null;
        }
      }

      fetch("/data/staticData.json")
        .then((r) => r.json())
        .then(build);

      function build(data) {
        const techs = data.types.filter((t) => t.key && t.key.startsWith("technologyType:"));
        const byKey = {};
        techs.forEach((t) => (byKey[t.key] = t));

        // ── era colour palette ──────────────────────────────────────────────────────
        const eraColors = {
          "eraType:neolithic": "#3fb950",
          "eraType:ancient": "#d29922",
          "eraType:classical": "#e3b341",
          "eraType:medieval": "#a371f7",
          "eraType:renaissance": "#f78166",
          "eraType:industrial": "#79c0ff",
          "eraType:modern": "#58a6ff",
          "eraType:atomic": "#ffa657",
          "eraType:digital": "#ff7b72",
          "eraType:nano": "#d2a8ff",
        };

        function eraColor(cat) {
          return eraColors[cat] || "#8b949e";
        }

        // ── canvas size ─────────────────────────────────────────────────────────────
        const maxX = Math.max(...techs.map((t) => t.x || 0));
        const maxY = Math.max(...techs.map((t) => t.y || 0));
        const W = maxX * CELL_W + NODE_W + PAD_X * 2;
        const H = maxY * CELL_H + NODE_H_MIN + PAD_Y * 2;

        const svg = document.getElementById("lines");
        svg.setAttribute("width", W);
        svg.setAttribute("height", H);
        svg.setAttribute("viewBox", `0 0 ${W} ${H}`);

        // ── node positions (centre of each node) ────────────────────────────────────
        function nodePos(tech) {
          return {
            x: PAD_X + (tech.x || 0) * CELL_W,
            y: PAD_Y + (tech.y || 0) * CELL_H,
          };
        }

        // ── draw nodes ──────────────────────────────────────────────────────────────
        const container = document.getElementById("nodes");
        const nodeEls = {};

        techs.forEach((tech) => {
          const pos = nodePos(tech);
          const color = eraColor(tech.category);

          // allowed items that are NOT technologyType
          const allowedItems = (tech.allows || [])
            .filter((a) => !a.startsWith("technologyType:"))
            .map((a) => {
              // pretty-print: "improvementType:farm" → "Farm (Improvement)"
              const [typeRaw, nameRaw] = a.split(":");
              const typePretty = typeRaw
                .replace("Type", "")
                .replace(/([A-Z])/g, " $1")
                .trim()
                .replace(/^./, (c) => c.toUpperCase());
              const namePretty = nameRaw
                ? nameRaw
                    .replace(/([A-Z])/g, " $1")
                    .replace(/^./, (c) => c.toUpperCase())
                    .trim()
                : a;
              return `${namePretty} (${typePretty})`;
            });

          const div = document.createElement("div");
          div.className = "tech-node";
          div.dataset.key = tech.key;
          div.style.left = pos.x + "px";
          div.style.top = pos.y + "px";
          div.style.borderTopColor = color;
          div.style.borderTopWidth = "2px";

          const eraLabel = tech.category
            ? tech.category
                .replace("eraType:", "")
                .replace(/([A-Z])/g, " $1")
                .trim()
            : "";

          const THRESHOLD = 5;
          const SHOW = 3;
          const truncate = allowedItems.length > THRESHOLD;
          const extraCount = truncate ? allowedItems.length - SHOW : 0;

          const itemsHtml = allowedItems.length
            ? `<ul class="items">${allowedItems
                .map(
                  (item, idx) =>
                    `<li title="${item}"${truncate && idx >= SHOW ? ' class="hidden"' : ""}>${item}</li>`,
                )
                .join(
                  "",
                )}</ul>${extraCount > 0 ? `<button class="toggle-more">+${extraCount} more</button>` : ""}`
            : "";

          div.innerHTML = `
            <div class="title">${tech.name} <span style="color:#8b949e;font-weight:400;font-size:9px">(${tech.x ?? 0},${tech.y ?? 0})</span></div>
            ${eraLabel ? `<div class="era" style="color:${color}">${eraLabel}</div>` : ""}
            ${itemsHtml}
          `;

          if (extraCount > 0) {
            const btn = div.querySelector(".toggle-more");
            const hiddenItems = div.querySelectorAll(".items li.hidden");
            btn.addEventListener("click", (e) => {
              e.stopPropagation();
              const expanded = btn.dataset.expanded === "1";
              hiddenItems.forEach((li) => li.classList.toggle("hidden", expanded));
              btn.dataset.expanded = expanded ? "0" : "1";
              btn.textContent = expanded ? `+${extraCount} more` : "hide";
            });
          }

          container.appendChild(div);
          nodeEls[tech.key] = { el: div, tech, pos };
        });

        // ── draw era separators ─────────────────────────────────────────────────────
        const separatorsContainer = document.getElementById("separators");
        // Era changes at y: 0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98, 105, 112, 119, 126
        const eras = [
          { y: 0, name: "Neolithic Era", category: "eraType:neolithic" },
          { y: 7, name: "Copper Era", category: "eraType:copper" },
          { y: 14, name: "Bronze Era", category: "eraType:bronze" },
          { y: 21, name: "Late Bronze Era", category: "eraType:lateBronze" },
          { y: 28, name: "Iron Era", category: "eraType:iron" },
          { y: 35, name: "Classical Era", category: "eraType:classical" },
          { y: 42, name: "Medieval Era", category: "eraType:medieval" },
          { y: 49, name: "Renaissance Era", category: "eraType:renaissance" },
          { y: 56, name: "Exploration Era", category: "eraType:exploration" },
          { y: 63, name: "Colonial Era", category: "eraType:colonial" },
          { y: 70, name: "Enlightenment Era", category: "eraType:enlightenment" },
          { y: 77, name: "Industrial Era", category: "eraType:industrial" },
          { y: 84, name: "Imperial Era", category: "eraType:imperial" },
          { y: 91, name: "Modern Era", category: "eraType:modern" },
          { y: 98, name: "Atomic Era", category: "eraType:atomic" },
          { y: 105, name: "Digital Era", category: "eraType:digital" },
          { y: 112, name: "Information Era", category: "eraType:information" },
          { y: 119, name: "Post-Industrial Era", category: "eraType:postIndustrial" },
          { y: 126, name: "Nano Era", category: "eraType:nano" },
        ];

        eras.forEach((era) => {
          const separator = document.createElement("div");
          separator.className = "era-separator";
          // Place 1y above the first tech of the era
          const yPos = PAD_Y + (era.y - 1) * CELL_H;
          separator.style.top = yPos + "px";
          separator.style.width = W + "px";

          const heading = document.createElement("h1");
          heading.textContent = era.name;
          heading.style.color = eraColor(era.category);
          separator.appendChild(heading);

          separatorsContainer.appendChild(separator);
        });

        // ── draw vertical timeline ──────────────────────────────────────────────────
        const timelineContainer = document.getElementById("timeline");

        // Add getYearFromTurn function
        const yearsPerTurnConfig = [
          { start: -10000, end: -7000, yearsPerTurn: 60 },
          { start: -7000, end: -4000, yearsPerTurn: 60 },
          { start: -4000, end: -2500, yearsPerTurn: 30 },
          { start: -2500, end: -1000, yearsPerTurn: 30 },
          { start: -1000, end: -250, yearsPerTurn: 15 },
          { start: -250, end: 500, yearsPerTurn: 15 },
          { start: 500, end: 1000, yearsPerTurn: 10 },
          { start: 1000, end: 1400, yearsPerTurn: 8 },
          { start: 1400, end: 1600, yearsPerTurn: 4 },
          { start: 1600, end: 1700, yearsPerTurn: 2 },
          { start: 1700, end: 1775, yearsPerTurn: 1.5 },
          { start: 1775, end: 1850, yearsPerTurn: 1.5 },
          { start: 1850, end: 1900, yearsPerTurn: 1 },
          { start: 1900, end: 1950, yearsPerTurn: 1 },
          { start: 1950, end: 1975, yearsPerTurn: 0.5 },
          { start: 1975, end: 2000, yearsPerTurn: 0.5 },
          { start: 2000, end: 2015, yearsPerTurn: 0.333 },
          { start: 2015, end: 2030, yearsPerTurn: 0.333 },
          { start: 2030, end: 99999999, yearsPerTurn: 0.333 },
        ];

        function getYearFromTurn(turn) {
          if (turn <= 0) return yearsPerTurnConfig[0].start;
          let remainingTurns = turn;
          for (const era of yearsPerTurnConfig) {
            const yearsInEra = era.end - era.start;
            const turnsInEra = yearsInEra / era.yearsPerTurn;
            if (remainingTurns >= turnsInEra) {
              remainingTurns -= turnsInEra;
              continue;
            }
            return era.start + remainingTurns * era.yearsPerTurn;
          }
          const last = yearsPerTurnConfig[yearsPerTurnConfig.length - 1];
          return last.start + remainingTurns * last.yearsPerTurn;
        }

        function formatYear(year) {
          const fullYear = Math.round(year);
          if (fullYear < 0) return `${-fullYear} BCE`;
          if (fullYear < 1000) return `${fullYear} CE`;
          return `${fullYear}`;
        }

        // Each y represents (50/7 = approx 7.14) turns, start at -1y to align with horizontal lines
        // Position timeline at -1x
        for (let y = 0; y <= maxY; y++) {
          const turn = Math.round(y * (50/7));
          const year = getYearFromTurn(turn);
          const mark = document.createElement("div");
          mark.className = "timeline-mark";
          mark.style.top = (PAD_Y + (y - 1) * CELL_H) + "px";
          mark.style.left = (PAD_X - CELL_W) + "px";
          mark.textContent = formatYear(year);
          timelineContainer.appendChild(mark);
        }

        // ── draw lines ──────────────────────────────────────────────────────────────
        // Build edges: for each tech, draw to each technologyType it `allows`
        // Also honour `requires` (draw from required → this)
        const edges = new Set();

        techs.forEach((tech) => {
          const src = nodePos(tech);

          // allows → technologyType children
          (tech.allows || []).forEach((targetKey) => {
            if (!targetKey.startsWith("technologyType:")) return;
            const target = byKey[targetKey];
            if (!target) return;
            const edgeId = [tech.key, targetKey].sort().join("|");
            if (edges.has(edgeId)) return;
            edges.add(edgeId);

            const dst = nodePos(target);
            drawEdge(svg, src, dst, eraColor(tech.category));
          });

          // requires → draw from requirement to this node
          (tech.requires || []).forEach((reqKey) => {
            if (!reqKey.startsWith("technologyType:")) return;
            const req = byKey[reqKey];
            if (!req) return;
            const edgeId = [tech.key, reqKey].sort().join("|");
            if (edges.has(edgeId)) return;
            edges.add(edgeId);

            const reqPos = nodePos(req);
            drawEdge(svg, reqPos, src, eraColor(req.category));
          });
        });

        // ── fit initial view ─────────────────────────────────────────────────────────
        initPanZoom(W, H);
      }

      function drawEdge(svg, src, dst, color) {
        // centres: x + half width, y + half of a nominal node height
        const x1 = src.x + NODE_W / 2;
        const y1 = src.y + NODE_H_MIN / 2;
        const x2 = dst.x + NODE_W / 2;
        const y2 = dst.y + NODE_H_MIN / 2;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("stroke", color);
        line.setAttribute("stroke-width", "3");
        line.setAttribute("stroke-opacity", "0.55");
        svg.appendChild(line);
      }

      // ── Pan & Zoom ────────────────────────────────────────────────────────────────
      let scale = 1,
        tx = 0,
        ty = 0;
      const viewport = document.getElementById("viewport");
      const wrap = document.getElementById("canvas-wrap");

      function applyTransform() {
        wrap.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
        saveView();
      }

      function zoom(factor, cx, cy) {
        const vw = viewport.clientWidth;
        const vh = viewport.clientHeight;
        cx = cx ?? vw / 2;
        cy = cy ?? vh / 2;
        const newScale = Math.max(0.08, Math.min(3, scale * factor));
        tx = cx - (cx - tx) * (newScale / scale);
        ty = cy - (cy - ty) * (newScale / scale);
        scale = newScale;
        applyTransform();
      }

      function resetView() {
        scale = 1;
        tx = 0;
        ty = 0;
        applyTransform();
        fitToScreen();
      }

      function fitToScreen() {
        const vw = viewport.clientWidth;
        const vh = viewport.clientHeight;
        // read actual canvas size from svg
        const svg = document.getElementById("lines");
        const cw = parseFloat(svg.getAttribute("width") || 3000);
        const ch = parseFloat(svg.getAttribute("height") || 1000);
        const s = Math.min(vw / cw, vh / ch) * 0.95;
        scale = s;
        tx = (vw - cw * s) / 2;
        ty = (vh - ch * s) / 2;
        applyTransform();
      }

      // wheel zoom
      viewport.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY < 0 ? 1.1 : 0.9;
          zoom(factor, e.clientX, e.clientY);
        },
        { passive: false },
      );

      // drag pan
      let dragging = false,
        dragStart = { x: 0, y: 0 };
      viewport.addEventListener("mousedown", (e) => {
        dragging = true;
        dragStart = { x: e.clientX - tx, y: e.clientY - ty };
        viewport.classList.add("dragging");
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        tx = e.clientX - dragStart.x;
        ty = e.clientY - dragStart.y;
        applyTransform();
      });
      window.addEventListener("mouseup", () => {
        dragging = false;
        viewport.classList.remove("dragging");
      });

      // touch pan
      let lastTouch = null;
      viewport.addEventListener("touchstart", (e) => {
        if (e.touches.length === 1)
          lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      });
      viewport.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          if (e.touches.length === 1 && lastTouch) {
            tx += e.touches[0].clientX - lastTouch.x;
            ty += e.touches[0].clientY - lastTouch.y;
            lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            applyTransform();
          }
        },
        { passive: false },
      );

      function initPanZoom(W, H) {
        const saved = loadView();
        if (saved) {
          scale = saved.scale;
          tx = saved.tx;
          ty = saved.ty;
          applyTransform();
        } else {
          setTimeout(fitToScreen, 50);
        }
      }
    </script>
  </body>
</html>
